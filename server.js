const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { Pool } = require('pg');
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const path = require('path');
const compression = require('compression');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// ÌôòÍ≤ΩÎ≥ÄÏàò Í≤ÄÏ¶ù Î∞è Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
const config = {
    JWT_SECRET: process.env.JWT_SECRET || 'oseong-middle-school-2025-super-secret-key',
    ADMIN_PASSWORD: process.env.ADMIN_PASSWORD || 'admin123',
    INIT_KEY: process.env.INIT_KEY || 'default-init-key',
    BCRYPT_SALT_ROUNDS: parseInt(process.env.BCRYPT_SALT_ROUNDS) || 12,
    RATE_LIMIT_MAX_REQUESTS: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
    RATE_LIMIT_WINDOW_MS: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 15 * 60 * 1000,
    LOG_LEVEL: process.env.LOG_LEVEL || 'info',
    NODE_ENV: process.env.NODE_ENV || 'development',
    CORS_ORIGIN: process.env.CORS_ORIGIN
};

// ÌïÑÏàò ÌôòÍ≤ΩÎ≥ÄÏàò Í≤ÄÏ¶ù
if (!process.env.DATABASE_URL) {
    console.error('‚ùå DATABASE_URL ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
    process.exit(1);
}

// ÏãúÏä§ÌÖú Ï†ïÎ≥¥
const SYSTEM_INFO = {
    name: 'Ïò§ÏÑ±Ï§ëÌïôÍµê ÎèôÏïÑÎ¶¨ Ìé∏ÏÑ± ÏãúÏä§ÌÖú',
    version: '1.0.4',
    startTime: new Date(),
    environment: config.NODE_ENV
};

console.log(`üöÄ ${SYSTEM_INFO.name} v${SYSTEM_INFO.version} ÏãúÏûë`);
console.log(`üìÖ ÏãúÏûë ÏãúÍ∞Ñ: ${SYSTEM_INFO.startTime.toISOString()}`);
console.log(`üåç ÌôòÍ≤Ω: ${SYSTEM_INFO.environment}`);

// ÏïïÏ∂ï ÎØ∏Îì§Ïõ®Ïñ¥
app.use(compression({
    level: 6,
    threshold: 1024
}));

// Î≥¥Ïïà ÎØ∏Îì§Ïõ®Ïñ¥ (CSP ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî - React Babel Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥)
app.use(helmet({
    contentSecurityPolicy: false,  // CSP ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî
    crossOriginEmbedderPolicy: false,
    hsts: config.NODE_ENV === 'production' ? {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    } : false
}));

// Rate limiting ÏÑ§Ï†ï
const createRateLimiter = (windowMs, max, message, skipPaths = []) => {
    return rateLimit({
        windowMs: windowMs || config.RATE_LIMIT_WINDOW_MS,
        max: max || config.RATE_LIMIT_MAX_REQUESTS,
        message: { error: message, retryAfter: Math.ceil(windowMs / 1000) },
        standardHeaders: true,
        legacyHeaders: false,
        skip: (req) => {
            return skipPaths.includes(req.path) || 
                   req.path.startsWith('/static/') ||
                   req.path === '/favicon.ico';
        }
    });
};

const generalLimiter = createRateLimiter(
    config.RATE_LIMIT_WINDOW_MS,
    config.NODE_ENV === 'production' ? config.RATE_LIMIT_MAX_REQUESTS : 1000,
    'ÎÑàÎ¨¥ ÎßéÏùÄ ÏöîÏ≤≠ÏùÑ Î≥¥ÎÉàÏäµÎãàÎã§. 15Î∂Ñ ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.',
    ['/api/health', '/check-database', '/init-database']
);

const loginLimiter = createRateLimiter(
    15 * 60 * 1000,
    5,
    'Î°úÍ∑∏Ïù∏ ÏãúÎèÑÍ∞Ä ÎÑàÎ¨¥ ÎßéÏäµÎãàÎã§. 15Î∂Ñ ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.'
);

const registerLimiter = createRateLimiter(
    60 * 60 * 1000,
    3,
    'ÌöåÏõêÍ∞ÄÏûÖ ÏãúÎèÑÍ∞Ä ÎÑàÎ¨¥ ÎßéÏäµÎãàÎã§. 1ÏãúÍ∞Ñ ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.'
);

app.use(generalLimiter);

// CORS ÏÑ§Ï†ï
const corsOptions = {
    origin: function (origin, callback) {
        const allowedOrigins = [
            config.CORS_ORIGIN,
            'https://oseong-club-selection.onrender.com'
        ].filter(Boolean);

        if (config.NODE_ENV !== 'production') {
            allowedOrigins.push('http://localhost:3000', 'http://127.0.0.1:3000');
        }

        if (!origin) return callback(null, true);
        
        if (allowedOrigins.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            callback(new Error('CORS policy violation'));
        }
    },
    credentials: true,
    optionsSuccessStatus: 200,
    maxAge: 86400
};

app.use(cors(corsOptions));

// ÎØ∏Îì§Ïõ®Ïñ¥ ÏÑ§Ï†ï
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Ï†ïÏ†Å ÌååÏùº Ï†úÍ≥µ
app.use(express.static('public', {
    maxAge: config.NODE_ENV === 'production' ? '1d' : '0',
    etag: true,
    lastModified: true
}));

app.get('/favicon.ico', (req, res) => {
    res.status(204).send();
});

// Î°úÍπÖ ÎØ∏Îì§Ïõ®Ïñ¥
app.use((req, res, next) => {
    const start = Date.now();
    const originalSend = res.send;
    
    const skipLogging = ['/favicon.ico', '/api/health'];
    
    res.send = function(data) {
        const duration = Date.now() - start;
        const status = res.statusCode;
        const method = req.method;
        const url = req.url;
        const ip = req.ip || req.connection.remoteAddress;
        
        if (!skipLogging.includes(url)) {
            if (status >= 400) {
                console.warn(`‚ö†Ô∏è ${method} ${url} ${status} ${duration}ms - ${ip}`);
            } else if (config.LOG_LEVEL === 'debug') {
                console.log(`‚úÖ ${method} ${url} ${status} ${duration}ms`);
            }
        }
        
        return originalSend.call(this, data);
    };
    
    next();
});

// PostgreSQL Ïó∞Í≤∞ ÏÑ§Ï†ï
const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: config.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 5000,
    acquireTimeoutMillis: 60000,
    statementTimeout: 30000,
    query_timeout: 30000,
    keepAlive: true,
    keepAliveInitialDelayMillis: 10000
});

// JWT ÎØ∏Îì§Ïõ®Ïñ¥
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.status(401).json({ 
            error: 'Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§',
            code: 'NO_TOKEN'
        });
    }

    jwt.verify(token, config.JWT_SECRET, (err, user) => {
        if (err) {
            const errorMessages = {
                'JsonWebTokenError': 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÜ†ÌÅ∞ÏûÖÎãàÎã§',
                'TokenExpiredError': 'ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§',
                'NotBeforeError': 'ÌÜ†ÌÅ∞Ïù¥ ÏïÑÏßÅ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§'
            };
            
            return res.status(403).json({ 
                error: errorMessages[err.name] || 'ÌÜ†ÌÅ∞ Í≤ÄÏ¶ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§',
                code: 'INVALID_TOKEN'
            });
        }
        
        req.user = user;
        next();
    });
};

// Í¥ÄÎ¶¨Ïûê Í∂åÌïú ÌôïÏù∏
const requireAdmin = (req, res, next) => {
    if (req.user.role !== 'admin') {
        return res.status(403).json({ 
            error: 'Í¥ÄÎ¶¨Ïûê Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§',
            code: 'ADMIN_REQUIRED'
        });
    }
    next();
};

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨ ÎûòÌçº
const dbQuery = async (query, params = []) => {
    const client = await pool.connect();
    try {
        const result = await client.query(query, params);
        return result;
    } catch (error) {
        console.error('‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨ Ïò§Î•ò:', error.message);
        throw error;
    } finally {
        client.release();
    }
};

// ============= Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî API =============
app.get('/init-database', async (req, res) => {
    const { key } = req.query;
    
    if (key !== config.INIT_KEY) {
        return res.status(403).json({ 
            error: 'Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏùÄ Ï¥àÍ∏∞Ìôî ÌÇ§ÏûÖÎãàÎã§',
            code: 'INVALID_INIT_KEY'
        });
    }
    
    const client = await pool.connect();
    
    try {
        console.log('üîÑ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî ÏãúÏûë...');
        
        await client.query('BEGIN');
        
        // Í∏∞Ï°¥ ÌÖåÏù¥Î∏î ÏÇ≠Ï†ú
        await client.query('DROP TABLE IF EXISTS applications CASCADE');
        await client.query('DROP TABLE IF EXISTS clubs CASCADE');
        await client.query('DROP TABLE IF EXISTS users CASCADE');
        
        // users ÌÖåÏù¥Î∏î ÏÉùÏÑ±
        await client.query(`
            CREATE TABLE users (
                id SERIAL PRIMARY KEY,
                username VARCHAR(50) UNIQUE NOT NULL,
                password VARCHAR(255) NOT NULL,
                name VARCHAR(100) NOT NULL,
                role VARCHAR(20) DEFAULT 'student',
                class_info VARCHAR(50),
                student_id VARCHAR(10),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_login TIMESTAMP
            )
        `);
        
        // clubs ÌÖåÏù¥Î∏î ÏÉùÏÑ±
        await client.query(`
            CREATE TABLE clubs (
                id SERIAL PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                teacher VARCHAR(100) NOT NULL,
                max_capacity INTEGER DEFAULT 30,
                min_members INTEGER DEFAULT 5,
                category VARCHAR(50) DEFAULT 'ÏùºÎ∞ò ÌôúÎèô',
                description TEXT,
                activities TEXT,
                goals TEXT,
                requirements TEXT,
                meeting_time VARCHAR(100),
                location VARCHAR(100),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // applications ÌÖåÏù¥Î∏î ÏÉùÏÑ±
        await client.query(`
            CREATE TABLE applications (
                id SERIAL PRIMARY KEY,
                user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
                club_id INTEGER REFERENCES clubs(id) ON DELETE CASCADE,
                priority INTEGER NOT NULL,
                status VARCHAR(20) DEFAULT 'pending',
                applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                assigned_at TIMESTAMP
            )
        `);
        
        // Í¥ÄÎ¶¨Ïûê Í≥ÑÏ†ï ÏÉùÏÑ±
        const hashedAdminPassword = await bcrypt.hash(config.ADMIN_PASSWORD, config.BCRYPT_SALT_ROUNDS);
        await client.query(
            'INSERT INTO users (username, password, name, role) VALUES ($1, $2, $3, $4)',
            ['admin', hashedAdminPassword, 'ÏãúÏä§ÌÖú Í¥ÄÎ¶¨Ïûê', 'admin']
        );
        
        // ÏÉòÌîå ÎèôÏïÑÎ¶¨ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
        const clubs = [
            ['Ï∂ïÍµ¨Î∂Ä', 'ÍπÄÏ≤†Ïàò', 25, 10, 'Ï≤¥Ïú° ÌôúÎèô', 'Ï∂ïÍµ¨Î•º ÌÜµÌïú Ï≤¥Î†• Ï¶ùÏßÑÍ≥º ÌòëÎèôÏã¨ Î∞∞Ïñë', 'Ï∂ïÍµ¨ Í≤ΩÍ∏∞, Ï≤¥Î†• ÌõàÎ†®, ÌåÄÏõåÌÅ¨ ÌõàÎ†®', 'Í±¥Í∞ïÌïú Ïã†Ï≤¥ÏôÄ ÌòëÎèôÏã¨ Í∏∞Î•¥Í∏∞', 'Ï≤¥Î†• Î∞è Ïö¥ÎèôÏã†Í≤Ω', 'ÌôîÏöîÏùº 7ÍµêÏãú', 'Ïö¥ÎèôÏû•'],
            ['ÎÜçÍµ¨Î∂Ä', 'Ïù¥ÏòÅÌù¨', 20, 8, 'Ï≤¥Ïú° ÌôúÎèô', 'ÎÜçÍµ¨Î•º ÌÜµÌïú ÌÇ§ ÏÑ±Ïû•Í≥º ÏàúÎ∞úÎ†• Ìñ•ÏÉÅ', 'ÎÜçÍµ¨ Í≤ΩÍ∏∞, ÎìúÎ¶¨Î∏î Ïó∞Ïäµ, Ïäõ Ïó∞Ïäµ', 'ÎÜçÍµ¨ Ïã§Î†• Ìñ•ÏÉÅÍ≥º Ïã†Ï≤¥ Î∞úÎã¨', 'ÌÇ§ 150cm Ïù¥ÏÉÅ', 'Î™©ÏöîÏùº 7ÍµêÏãú', 'Ï≤¥Ïú°Í¥Ä'],
            ['ÎØ∏Ïà†Î∂Ä', 'Î∞ïÏßÄÏó∞', 30, 5, 'ÏòàÏà† ÌôúÎèô', 'Îã§ÏñëÌïú ÎØ∏Ïà† Í∏∞Î≤ï ÌïôÏäµÍ≥º Ï∞ΩÏûë ÌôúÎèô', 'Í∑∏Î¶¨Í∏∞, ÎßåÎì§Í∏∞, Ï†ÑÏãúÌöå Ï§ÄÎπÑ', 'ÏòàÏà†Ï†Å Í∞êÏÑ±Í≥º Ï∞ΩÏùòÎ†• Í∞úÎ∞ú', 'ÎØ∏Ïà†Ïóê ÎåÄÌïú Í¥ÄÏã¨', 'Í∏àÏöîÏùº 7ÍµêÏãú', 'ÎØ∏Ïà†Ïã§'],
            ['ÏùåÏïÖÎ∂Ä', 'ÏµúÎØºÏàò', 35, 10, 'ÏòàÏà† ÌôúÎèô', 'Ìï©Ï∞ΩÍ≥º ÏïÖÍ∏∞ Ïó∞Ï£ºÎ•º ÌÜµÌïú ÏùåÏïÖÏ†Å Ïû¨Îä• Í∞úÎ∞ú', 'Ìï©Ï∞Ω, ÏïÖÍ∏∞ Ïó∞Ï£º, Î∞úÌëúÌöå Ï§ÄÎπÑ', 'ÏùåÏïÖÏ†Å ÏÜåÏñëÍ≥º ÌëúÌòÑÎ†• Ìñ•ÏÉÅ', 'ÏùåÏïÖÏóê ÎåÄÌïú Ïó¥Ï†ï', 'ÏàòÏöîÏùº 7ÍµêÏãú', 'ÏùåÏïÖÏã§'],
            ['Í≥ºÌïôÏã§ÌóòÎ∂Ä', 'Ï†ïÌò∏ÏòÅ', 25, 8, 'ÌïôÏà† ÌôúÎèô', 'Í≥ºÌïô Ïã§ÌóòÏùÑ ÌÜµÌïú ÌÉêÍµ¨Î†•Í≥º ÏÇ¨Í≥†Î†• Î∞∞Ïñë', 'Ïã§Ìóò, ÌÉêÍµ¨ÌôúÎèô, Í≥ºÌïôÏ†ÑÎûåÌöå Ï§ÄÎπÑ', 'Í≥ºÌïôÏ†Å ÏÇ¨Í≥†Î†•Í≥º ÌÉêÍµ¨Ï†ïÏã† Í∏∞Î•¥Í∏∞', 'Í≥ºÌïô Í¥ÄÎ†® Í≥ºÎ™© ÌèâÍ∑† 80Ï†ê Ïù¥ÏÉÅ', 'ÏõîÏöîÏùº 7ÍµêÏãú', 'Í≥ºÌïôÏã§'],
            ['ÎèÖÏÑúÌÜ†Î°†Î∂Ä', 'Í∞ïÏàòÏßÑ', 20, 6, 'ÌïôÏà† ÌôúÎèô', 'Ï±Ö ÏùΩÍ∏∞ÏôÄ ÌÜ†Î°†ÏùÑ ÌÜµÌïú ÏÇ¨Í≥†Î†• Ï¶ùÏßÑ', 'ÎèÖÏÑú, ÌÜ†Î°†, ÎèÖÌõÑÍ∞ê ÏûëÏÑ±', 'ÎèÖÏÑú ÏäµÍ¥ÄÍ≥º ÎÖºÎ¶¨Ï†Å ÏÇ¨Í≥†Î†• Í∏∞Î•¥Í∏∞', 'ÎèÖÏÑúÏóê ÎåÄÌïú Í¥ÄÏã¨', 'ÌôîÏöîÏùº 7ÍµêÏãú', 'ÎèÑÏÑúÍ¥Ä'],
            ['Ïª¥Ìì®ÌÑ∞Î∂Ä', 'ÏûÑÍ∏∞ÏõÖ', 30, 10, 'Í∏∞Ïà† ÌôúÎèô', 'Ïª¥Ìì®ÌÑ∞ ÌôúÏö© Îä•Î†•Í≥º ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç Í∏∞Ï¥à ÌïôÏäµ', 'ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç, ÌôàÌéòÏù¥ÏßÄ Ï†úÏûë, Ïª¥Ìì®ÌÑ∞ Ï°∞Î¶Ω', 'IT Í∏∞Ïà† ÏäµÎìùÍ≥º ÎîîÏßÄÌÑ∏ ÏÜåÏñë Í∏∞Î•¥Í∏∞', 'Ïª¥Ìì®ÌÑ∞ Í∏∞Ï¥à ÏßÄÏãù', 'Î™©ÏöîÏùº 7ÍµêÏãú', 'Ïª¥Ìì®ÌÑ∞Ïã§'],
            ['ÏòÅÏñ¥ÌöåÌôîÎ∂Ä', 'ÍπÄÎÇòÏòÅ', 25, 8, 'Ïñ∏Ïñ¥ ÌôúÎèô', 'ÏõêÏñ¥ÎØºÍ≥ºÏùò ÎåÄÌôîÎ•º ÌÜµÌïú ÏòÅÏñ¥ Ïã§Î†• Ìñ•ÏÉÅ', 'ÏòÅÏñ¥ ÌöåÌôî, Í≤åÏûÑ, ÏòÅÏñ¥ Ïó∞Í∑π', 'Ïã§Ïö©Ï†ÅÏù∏ ÏòÅÏñ¥ ÌöåÌôî Îä•Î†• Í∏∞Î•¥Í∏∞', 'ÏòÅÏñ¥Ïóê ÎåÄÌïú Í¥ÄÏã¨', 'Í∏àÏöîÏùº 7ÍµêÏãú', 'ÏòÅÏñ¥Ï†ÑÏö©ÍµêÏã§'],
            ['Î∞©ÏÜ°Î∂Ä', 'ÏÑúÎèôÌòÅ', 15, 5, 'ÎØ∏ÎîîÏñ¥ ÌôúÎèô', 'Î∞©ÏÜ° Ï†úÏûëÍ≥º ÏïÑÎÇòÏö¥Ïã± Í∏∞Ïà† ÏäµÎìù', 'Î∞©ÏÜ° Ï†úÏûë, ÏïÑÎÇòÏö¥Ïã±, ÏòÅÏÉÅ Ìé∏Ïßë', 'Î∞©ÏÜ° Í∏∞Ïà†Í≥º Î∞úÌëúÎ†• Í∏∞Î•¥Í∏∞', 'Î™©ÏÜåÎ¶¨Í∞Ä Ï¢ãÍ≥† Î∞úÌëúÎ•º Ï¢ãÏïÑÌïòÎäî ÌïôÏÉù', 'ÏàòÏöîÏùº 7ÍµêÏãú', 'Î∞©ÏÜ°Ïã§'],
            ['ÌôòÍ≤ΩÎ≥¥Ìò∏Î∂Ä', 'Ïú§ÌÉúÏ§Ä', 20, 6, 'Î¥âÏÇ¨ ÌôúÎèô', 'ÌôòÍ≤Ω Î≥¥Ìò∏ Ïã§Ï≤úÍ≥º ÏÉùÌÉúÍ≥Ñ Î≥¥Ï†Ñ ÌôúÎèô', 'ÌôòÍ≤Ω Ï†ïÌôî, Ïû¨ÌôúÏö©, ÌôòÍ≤Ω Ï∫†ÌéòÏù∏', 'ÌôòÍ≤Ω ÏùòÏãùÍ≥º Ïã§Ï≤úÎ†• Í∏∞Î•¥Í∏∞', 'ÌôòÍ≤ΩÏóê ÎåÄÌïú Í¥ÄÏã¨', 'ÏõîÏöîÏùº 7ÍµêÏãú', 'Í≥ºÌïôÏã§']
        ];
        
        for (const club of clubs) {
            await client.query(
                `INSERT INTO clubs (name, teacher, max_capacity, min_members, category, description, activities, goals, requirements, meeting_time, location) 
                 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`,
                club
            );
        }
        
        await client.query('COMMIT');
        
        console.log('‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
        
        res.json({
            success: true,
            message: 'Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§!',
            data: {
                tables_created: ['users', 'clubs', 'applications'],
                admin_account: 'Í¥ÄÎ¶¨Ïûê Í≥ÑÏ†ï ÏÉùÏÑ± ÏôÑÎ£å',
                sample_clubs: clubs.length + 'Í∞ú ÎèôÏïÑÎ¶¨ Îç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä'
            }
        });
        
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
        res.status(500).json({ 
            error: 'Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§',
            details: error.message
        });
    } finally {
        client.release();
    }
});

// Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÉÅÌÉú ÌôïÏù∏
app.get('/check-database', async (req, res) => {
    try {
        const tableChecks = await Promise.all([
            dbQuery("SELECT COUNT(*) as count FROM information_schema.tables WHERE table_name = 'users'"),
            dbQuery("SELECT COUNT(*) as count FROM information_schema.tables WHERE table_name = 'clubs'"),
            dbQuery("SELECT COUNT(*) as count FROM information_schema.tables WHERE table_name = 'applications'")
        ]);
        
        const [usersTable, clubsTable, applicationsTable] = tableChecks;
        
        const tablesExist = {
            users: parseInt(usersTable.rows[0].count) > 0,
            clubs: parseInt(clubsTable.rows[0].count) > 0,
            applications: parseInt(applicationsTable.rows[0].count) > 0
        };
        
        const allTablesExist = Object.values(tablesExist).every(exists => exists);
        
        let counts = {};
        if (allTablesExist) {
            const countQueries = await Promise.all([
                dbQuery("SELECT COUNT(*) as count FROM users"),
                dbQuery("SELECT COUNT(*) as count FROM clubs"),
                dbQuery("SELECT COUNT(*) as count FROM applications")
            ]);
            
            counts = {
                users: parseInt(countQueries[0].rows[0].count),
                clubs: parseInt(countQueries[1].rows[0].count),
                applications: parseInt(countQueries[2].rows[0].count)
            };
        }
        
        res.json({
            database_status: allTablesExist ? 'ready' : 'needs_initialization',
            tables_exist: tablesExist,
            record_counts: counts,
            initialization_needed: !allTablesExist,
            init_url: !allTablesExist ? `/init-database?key=${config.INIT_KEY}` : null
        });
        
    } catch (error) {
        console.error('‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®:', error);
        res.status(500).json({ 
            error: 'Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÉÅÌÉúÎ•º ÌôïÏù∏Ìï† Ïàò ÏóÜÏäµÎãàÎã§',
            details: error.message
        });
    }
});

// ============= API ÎùºÏö∞Ìä∏ =============

// Ìó¨Ïä§Ï≤¥ÌÅ¨
app.get('/api/health', async (req, res) => {
    try {
        const dbResult = await dbQuery('SELECT NOW() as current_time');
        const uptime = process.uptime();
        const memory = process.memoryUsage();
        
        res.json({
            status: 'healthy',
            timestamp: new Date().toISOString(),
            service: SYSTEM_INFO.name,
            version: SYSTEM_INFO.version,
            environment: SYSTEM_INFO.environment,
            uptime: {
                seconds: Math.floor(uptime),
                human: `${Math.floor(uptime / 3600)}ÏãúÍ∞Ñ ${Math.floor((uptime % 3600) / 60)}Î∂Ñ`
            },
            database: {
                status: 'connected',
                server_time: dbResult.rows[0].current_time
            },
            memory: {
                used_mb: Math.round(memory.heapUsed / 1024 / 1024),
                total_mb: Math.round(memory.heapTotal / 1024 / 1024),
                rss_mb: Math.round(memory.rss / 1024 / 1024)
            },
            config: {
                cors_origin: config.CORS_ORIGIN,
                rate_limit: config.RATE_LIMIT_MAX_REQUESTS,
                bcrypt_rounds: config.BCRYPT_SALT_ROUNDS,
                log_level: config.LOG_LEVEL,
                csp_disabled: true  // CSP ÎπÑÌôúÏÑ±Ìôî ÌôïÏù∏Ïö©
            }
        });
        
    } catch (error) {
        console.error('‚ùå Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìå®:', error);
        res.status(503).json({
            status: 'unhealthy',
            error: 'Database connection failed'
        });
    }
});

// ÏãúÏä§ÌÖú Ï†ïÎ≥¥
app.get('/api/info', (req, res) => {
    res.json({
        name: SYSTEM_INFO.name,
        version: SYSTEM_INFO.version,
        description: '2025ÌïôÎÖÑÎèÑ Ï∞ΩÏ≤¥ÎèôÏïÑÎ¶¨ Ïã†Ï≤≠ Î∞è Ìé∏ÏÑ± Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú',
        started_at: SYSTEM_INFO.startTime,
        uptime_seconds: Math.floor(process.uptime()),
        environment: SYSTEM_INFO.environment,
        config: {
            bcrypt_rounds: config.BCRYPT_SALT_ROUNDS,
            rate_limit_max: config.RATE_LIMIT_MAX_REQUESTS,
            cors_origin: config.CORS_ORIGIN || 'Not set',
            csp_disabled: true
        }
    });
});

// ÌïôÏÉù ÌöåÏõêÍ∞ÄÏûÖ
app.post('/api/register', registerLimiter, async (req, res) => {
    const client = await pool.connect();
    
    try {
        const { student_number, name } = req.body;
        
        if (!student_number || !name) {
            return res.status(400).json({ 
                error: 'ÌïôÎ≤àÍ≥º Ïù¥Î¶ÑÏùÑ Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî',
                code: 'MISSING_FIELDS'
            });
        }
        
        if (!/^\d{4}$/.test(student_number)) {
            return res.status(400).json({ 
                error: 'ÌïôÎ≤àÏùÄ 4ÏûêÎ¶¨ Ïà´ÏûêÎ°ú ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî (Ïòà: 1101)',
                code: 'INVALID_STUDENT_NUMBER_FORMAT'
            });
        }
        
        if (!/^[Í∞Ä-Ìû£]{2,4}$/.test(name)) {
            return res.status(400).json({ 
                error: 'Ïù¥Î¶ÑÏùÄ ÌïúÍ∏Ä 2-4Í∏ÄÏûêÎ°ú ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî',
                code: 'INVALID_NAME_FORMAT'
            });
        }
        
        const grade = parseInt(student_number.charAt(0));
        const classNum = parseInt(student_number.charAt(1));
        
        if (grade < 1 || grade > 3) {
            return res.status(400).json({
                error: 'ÌïôÎÖÑÏùÄ 1-3 ÏÇ¨Ïù¥Ïó¨Ïïº Ìï©ÎãàÎã§'
            });
        }
        
        if (classNum < 1 || classNum > 9) {
            return res.status(400).json({
                error: 'Î∞òÏùÄ 1-9 ÏÇ¨Ïù¥Ïó¨Ïïº Ìï©ÎãàÎã§'
            });
        }
        
        await client.query('BEGIN');
        
        const existingUser = await client.query(
            'SELECT id, name FROM users WHERE username = $1', 
            [student_number]
        );
        
        if (existingUser.rows.length > 0) {
            await client.query('ROLLBACK');
            return res.status(409).json({ 
                error: 'Ïù¥ÎØ∏ Í∞ÄÏûÖÎêú ÌïôÎ≤àÏûÖÎãàÎã§',
                existing_name: existingUser.rows[0].name
            });
        }
        
        const password = await bcrypt.hash(student_number, config.BCRYPT_SALT_ROUNDS);
        const autoClassInfo = `${grade}ÌïôÎÖÑ ${classNum}Î∞ò`;
        
        const result = await client.query(
            `INSERT INTO users (username, password, name, role, class_info, student_id, created_at) 
             VALUES ($1, $2, $3, $4, $5, $6, NOW()) 
             RETURNING id, username, name, class_info`,
            [student_number, password, name, 'student', autoClassInfo, student_number]
        );
        
        await client.query('COMMIT');
        
        const newUser = result.rows[0];
        console.log(`‚úÖ ÏÉà ÌïôÏÉù Í∞ÄÏûÖ: ${newUser.name} (${newUser.username})`);
        
        res.status(201).json({
            success: true,
            message: 'Í∞ÄÏûÖÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!',
            user: {
                id: newUser.id,
                username: newUser.username,
                name: newUser.name,
                class_info: newUser.class_info
            },
            login_info: {
                username: student_number,
                password_hint: 'ÎπÑÎ∞ÄÎ≤àÌò∏Îäî ÌïôÎ≤àÍ≥º ÎèôÏùºÌï©ÎãàÎã§'
            }
        });
        
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('‚ùå ÌöåÏõêÍ∞ÄÏûÖ Ïò§Î•ò:', error);
        res.status(500).json({ 
            error: 'Í∞ÄÏûÖ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§'
        });
    } finally {
        client.release();
    }
});

// Î°úÍ∑∏Ïù∏
app.post('/api/login', loginLimiter, async (req, res) => {
    try {
        const { username, password } = req.body;
        
        if (!username || !password) {
            return res.status(400).json({ 
                error: 'ÏïÑÏù¥ÎîîÏôÄ ÎπÑÎ∞ÄÎ≤àÌò∏Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî'
            });
        }
        
        const userResult = await dbQuery(
            'SELECT id, username, password, name, role, class_info, student_id, last_login FROM users WHERE username = $1',
            [username]
        );
        
        if (userResult.rows.length === 0) {
            return res.status(401).json({ 
                error: 'ÏÇ¨Ïö©ÏûêÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§'
            });
        }
        
        const user = userResult.rows[0];
        const validPassword = await bcrypt.compare(password, user.password);
        
        if (!validPassword) {
            return res.status(401).json({ 
                error: 'ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä ÏùºÏπòÌïòÏßÄ ÏïäÏäµÎãàÎã§'
            });
        }
        
        const tokenPayload = {
            id: user.id,
            username: user.username,
            role: user.role,
            student_id: user.student_id || user.username,
            class_info: user.class_info
        };
        
        const token = jwt.sign(tokenPayload, config.JWT_SECRET, { expiresIn: '24h' });
        
        // ÎßàÏßÄÎßâ Î°úÍ∑∏Ïù∏ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
        dbQuery('UPDATE users SET last_login = NOW() WHERE id = $1', [user.id])
            .catch(err => console.warn('Î°úÍ∑∏Ïù∏ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:', err.message));
        
        console.log(`‚úÖ Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ: ${user.name} (${user.username})`);
        
        res.json({
            success: true,
            message: `ÌôòÏòÅÌï©ÎãàÎã§, ${user.name}Îãò!`,
            token,
            user: {
                id: user.id,
                username: user.username,
                name: user.name,
                role: user.role,
                student_id: user.student_id || user.username,
                class_info: user.class_info,
                last_login: user.last_login
            }
        });
        
    } catch (error) {
        console.error('‚ùå Î°úÍ∑∏Ïù∏ Ïò§Î•ò:', error);
        res.status(500).json({ 
            error: 'Î°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§'
        });
    }
});

// ÎèôÏïÑÎ¶¨ Î™©Î°ù Ï°∞Ìöå
app.get('/api/clubs', async (req, res) => {
    try {
        const result = await dbQuery(`
            SELECT 
                c.*,
                COALESCE(s.current_members, 0) as current_members,
                COALESCE(s.pending_applications, 0) as pending_applications,
                COALESCE(s.assigned_members, 0) as assigned_members,
                (
                    CASE 
                        WHEN COALESCE(s.current_members, 0) >= c.max_capacity THEN 'full'
                        WHEN COALESCE(s.current_members, 0) >= c.max_capacity * 0.8 THEN 'near_full'
                        ELSE 'available'
                    END
                ) as availability_status
            FROM clubs c
            LEFT JOIN (
                SELECT 
                    club_id,
                    COUNT(*) as current_members,
                    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_applications,
                    COUNT(CASE WHEN status = 'assigned' THEN 1 END) as assigned_members
                FROM applications
                GROUP BY club_id
            ) s ON c.id = s.club_id
            ORDER BY c.category, c.name
        `);
        
        const clubs = result.rows.map(club => ({
            ...club,
            max_members: club.max_capacity || 30,
            min_members: club.min_members || 5,
            category: club.category || 'ÏùºÎ∞ò ÌôúÎèô',
            activities: club.activities || club.description || 'Îã§ÏñëÌïú ÌôúÎèô',
            goals: club.goals || club.requirements || 'ÌïôÏÉù Ïó≠Îüâ Í∞úÎ∞ú',
            meeting_time: club.meeting_time || 'ÎØ∏Ï†ï',
            location: club.location || 'ÎØ∏Ï†ï'
        }));
        
        res.json({
            success: true,
            count: clubs.length,
            clubs: clubs,
            summary: {
                total_clubs: clubs.length,
                by_category: clubs.reduce((acc, club) => {
                    acc[club.category] = (acc[club.category] || 0) + 1;
                    return acc;
                }, {}),
                availability: {
                    available: clubs.filter(c => c.availability_status === 'available').length,
                    near_full: clubs.filter(c => c.availability_status === 'near_full').length,
                    full: clubs.filter(c => c.availability_status === 'full').length
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå ÎèôÏïÑÎ¶¨ Î™©Î°ù Ï°∞Ìöå Ïò§Î•ò:', error);
        res.status(500).json({ 
            error: 'ÎèôÏïÑÎ¶¨ Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§'
        });
    }
});

// ÌïôÏÉù ÎèôÏïÑÎ¶¨ Ïã†Ï≤≠
app.post('/api/apply', authenticateToken, async (req, res) => {
    const client = await pool.connect();
    
    try {
        const { first_choice, second_choice, third_choice } = req.body;
        const user_id = req.user.id;
        
        if (!first_choice) {
            return res.status(400).json({
                error: '1ÏßÄÎßùÏùÄ ÌïÑÏàòÎ°ú ÏÑ†ÌÉùÌï¥Ïïº Ìï©ÎãàÎã§'
            });
        }
        
        const choices = [first_choice, second_choice, third_choice].filter(Boolean);
        const uniqueChoices = [...new Set(choices)];
        
        if (choices.length !== uniqueChoices.length) {
            return res.status(400).json({
                error: 'Í∞ôÏùÄ ÎèôÏïÑÎ¶¨Î•º Ï§ëÎ≥µÏúºÎ°ú ÏÑ†ÌÉùÌï† Ïàò ÏóÜÏäµÎãàÎã§'
            });
        }
        
        const clubCheck = await client.query(
            `SELECT id, name, max_capacity FROM clubs WHERE id = ANY($1::int[])`,
            [choices]
        );
        
        if (clubCheck.rows.length !== choices.length) {
            return res.status(400).json({
                error: 'Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÎèôÏïÑÎ¶¨Í∞Ä Ìè¨Ìï®ÎêòÏñ¥ ÏûàÏäµÎãàÎã§'
            });
        }
        
        await client.query('BEGIN');
        
        const deleteResult = await client.query('DELETE FROM applications WHERE user_id = $1', [user_id]);
        
        const applications = [
            { club_id: first_choice, priority: 1 },
            { club_id: second_choice, priority: 2 },
            { club_id: third_choice, priority: 3 }
        ].filter(app => app.club_id);
        
        const insertPromises = applications.map(app =>
            client.query(
                `INSERT INTO applications (user_id, club_id, priority, status, applied_at) 
                 VALUES ($1, $2, $3, 'pending', NOW())`,
                [user_id, app.club_id, app.priority]
            )
        );
        
        await Promise.all(insertPromises);
        await client.query('COMMIT');
        
        console.log(`‚úÖ ÎèôÏïÑÎ¶¨ Ïã†Ï≤≠ ÏôÑÎ£å: ${req.user.name} - ${applications.length}Í∞ú ÏßÄÎßù`);
        
        const appliedClubs = clubCheck.rows.map(club => {
            const priority = applications.find(app => app.club_id === club.id)?.priority;
            return {
                club_id: club.id,
                club_name: club.name,
                priority: priority,
                max_capacity: club.max_capacity
            };
        }).sort((a, b) => a.priority - b.priority);
        
        res.json({
            success: true,
            message: 'ÎèôÏïÑÎ¶¨ Ïã†Ï≤≠Ïù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!',
            applications: appliedClubs,
            applied_at: new Date().toISOString()
        });
        
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('‚ùå ÎèôÏïÑÎ¶¨ Ïã†Ï≤≠ Ïò§Î•ò:', error);
        res.status(500).json({ 
            error: 'ÎèôÏïÑÎ¶¨ Ïã†Ï≤≠Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§'
        });
    } finally {
        client.release();
    }
});

// ÌïôÏÉù Ïã†Ï≤≠ ÌòÑÌô© Ï°∞Ìöå
app.get('/api/my-applications', authenticateToken, async (req, res) => {
    try {
        const user_id = req.user.id;
        
        const result = await dbQuery(`
            SELECT 
                a.*,
                c.name as club_name, 
                c.teacher, 
                c.location,
                c.meeting_time,
                c.max_capacity,
                a.priority as preference,
                a.applied_at,
                CASE 
                    WHEN a.status = 'assigned' THEN 'Î∞∞Ï†ï ÏôÑÎ£å'
                    WHEN a.status = 'rejected' THEN 'Î∞∞Ï†ï ÌÉàÎùΩ'
                    ELSE 'Î∞∞Ï†ï ÎåÄÍ∏∞'
                END as status_text
            FROM applications a
            JOIN clubs c ON a.club_id = c.id
            WHERE a.user_id = $1
            ORDER BY a.priority
        `, [user_id]);
        
        res.json({
            success: true,
            count: result.rows.length,
            applications: result.rows,
            summary: {
                total_applications: result.rows.length,
                status_breakdown: {
                    assigned: result.rows.filter(app => app.status === 'assigned').length,
                    pending: result.rows.filter(app => app.status === 'pending').length,
                    rejected: result.rows.filter(app => app.status === 'rejected').length
                },
                has_assignment: result.rows.some(app => app.status === 'assigned')
            }
        });
        
    } catch (error) {
        console.error('‚ùå Ïã†Ï≤≠ ÌòÑÌô© Ï°∞Ìöå Ïò§Î•ò:', error);
        res.status(500).json({ 
            error: 'Ïã†Ï≤≠ ÌòÑÌô©ÏùÑ Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§'
        });
    }
});

// Í¥ÄÎ¶¨Ïûê: Î™®Îì† Ïã†Ï≤≠ ÌòÑÌô©
app.get('/api/admin/applications', authenticateToken, requireAdmin, async (req, res) => {
    try {
        const result = await dbQuery(`
            SELECT 
                a.*,
                u.name as student_name,
                u.username as student_id,
                u.class_info,
                c.name as club_name,
                c.teacher,
                c.max_capacity as max_members,
                c.category,
                a.priority as preference,
                a.applied_at
            FROM applications a
            JOIN users u ON a.user_id = u.id
            JOIN clubs c ON a.club_id = c.id
            ORDER BY c.name, a.priority, u.name
        `);
        
        res.json({
            success: true,
            applications: result.rows
        });
        
    } catch (error) {
        console.error('‚ùå Í¥ÄÎ¶¨Ïûê Ïã†Ï≤≠ ÌòÑÌô© Ï°∞Ìöå Ïò§Î•ò:', error);
        res.status(500).json({ 
            error: 'Ïã†Ï≤≠ ÌòÑÌô©ÏùÑ Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§'
        });
    }
});

// Í¥ÄÎ¶¨Ïûê: ÎèôÏïÑÎ¶¨ Î∞∞Ï†ï Ïã§Ìñâ
app.post('/api/admin/assign-clubs', authenticateToken, requireAdmin, async (req, res) => {
    const client = await pool.connect();
    
    try {
        console.log(`üéØ ÎèôÏïÑÎ¶¨ Î∞∞Ï†ï ÏãúÏûë: ${req.user.name}`);
        const startTime = Date.now();
        
        await client.query('BEGIN');
        
        // Î™®Îì† Ïã†Ï≤≠ÏùÑ pendingÏúºÎ°ú Ï¥àÍ∏∞Ìôî
        await client.query("UPDATE applications SET status = 'pending'");
        
        let totalAssigned = 0;
        let totalRejected = 0;
        
        // 1ÏßÄÎßùÎ∂ÄÌÑ∞ 3ÏßÄÎßùÍπåÏßÄ ÏàúÏ∞®Ï†ÅÏúºÎ°ú Î∞∞Ï†ï
        for (let priority = 1; priority <= 3; priority++) {
            const applications = await client.query(`
                SELECT 
                    a.user_id, 
                    a.club_id, 
                    c.max_capacity,
                    u.name as student_name,
                    u.username as student_id,
                    c.name as club_name,
                    (SELECT COUNT(*) FROM applications a2 WHERE a2.club_id = a.club_id AND a2.status = 'assigned') as current_assigned
                FROM applications a
                JOIN clubs c ON a.club_id = c.id
                JOIN users u ON a.user_id = u.id
                WHERE a.priority = $1 
                  AND a.status = 'pending'
                  AND a.user_id NOT IN (
                      SELECT user_id FROM applications WHERE status = 'assigned'
                  )
                ORDER BY RANDOM()
            `, [priority]);
            
            let assignedInThisPriority = 0;
            
            for (const app of applications.rows) {
                if (app.current_assigned < app.max_capacity) {
                    // Î∞∞Ï†ï Í∞ÄÎä•
                    await client.query(
                        "UPDATE applications SET status = 'assigned' WHERE user_id = $1 AND club_id = $2",
                        [app.user_id, app.club_id]
                    );
                    
                    // Ìï¥Îãπ ÌïôÏÉùÏùò Îã§Î•∏ ÏßÄÎßù Ïã†Ï≤≠Îì§ÏùÑ rejectedÎ°ú Î≥ÄÍ≤Ω
                    await client.query(
                        "UPDATE applications SET status = 'rejected' WHERE user_id = $1 AND club_id != $2",
                        [app.user_id, app.club_id]
                    );
                    
                    assignedInThisPriority++;
                    totalAssigned++;
                }
            }
            
            console.log(`‚úÖ ${priority}ÏßÄÎßù Î∞∞Ï†ï ÏôÑÎ£å: ${assignedInThisPriority}Î™Ö`);
        }
        
        // ÏµúÏ¢Ö ÎØ∏Î∞∞Ï†ïÏûêÎì§ÏùÑ rejectedÎ°ú Ï≤òÎ¶¨
        const rejectedResult = await client.query(
            "UPDATE applications SET status = 'rejected' WHERE status = 'pending'"
        );
        totalRejected = rejectedResult.rowCount;
        
        await client.query('COMMIT');
        
        const duration = Date.now() - startTime;
        console.log(`üéâ ÎèôÏïÑÎ¶¨ Î∞∞Ï†ï ÏôÑÎ£å: ${totalAssigned}Î™Ö Î∞∞Ï†ï, ${totalRejected}Î™Ö ÎØ∏Î∞∞Ï†ï`);
        
        res.json({
            success: true,
            message: 'ÎèôÏïÑÎ¶¨ Î∞∞Ï†ïÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!',
            summary: {
                total_assigned: totalAssigned,
                total_rejected: totalRejected,
                assignment_duration_ms: duration
            }
        });
        
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('‚ùå ÎèôÏïÑÎ¶¨ Î∞∞Ï†ï Ïò§Î•ò:', error);
        res.status(500).json({ 
            error: 'ÎèôÏïÑÎ¶¨ Î∞∞Ï†ïÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§'
        });
    } finally {
        client.release();
    }
});

// ========================================
// ÏóêÎü¨ Ìï∏Îì§ÎßÅ Î∞è Ï†ïÏ†Å ÌååÏùº Ï†úÍ≥µ
// ========================================

// 404 ÏóêÎü¨ Ìï∏Îì§ÎßÅ (API ÎùºÏö∞Ìä∏)
app.use('/api/*', (req, res) => {
    res.status(404).json({
        error: 'ÏöîÏ≤≠ÌïòÏã† API ÏóîÎìúÌè¨Ïù∏Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§',
        requested_path: req.originalUrl
    });
});

// Ï†ÑÏó≠ ÏóêÎü¨ Ìï∏Îì§Îü¨
app.use((error, req, res, next) => {
    console.error('üö® ÏÑúÎ≤Ñ Ïò§Î•ò:', error.message);
    
    if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({
            error: 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÜ†ÌÅ∞ÏûÖÎãàÎã§'
        });
    }
    
    if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
            error: 'ÌÜ†ÌÅ∞Ïù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§'
        });
    }
    
    if (error.message === 'CORS policy violation') {
        return res.status(403).json({
            error: 'ÌóàÏö©ÎêòÏßÄ ÏïäÏùÄ ÎèÑÎ©îÏù∏ÏóêÏÑúÏùò ÏöîÏ≤≠ÏûÖÎãàÎã§'
        });
    }
    
    res.status(error.status || 500).json({
        error: config.NODE_ENV === 'production' ? 
            'ÏÑúÎ≤Ñ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§' : 
            error.message
    });
});

// Ï†ïÏ†Å ÌååÏùº Ï†úÍ≥µ (React Ïï±)
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'), (err) => {
        if (err) {
            console.error('Ï†ïÏ†Å ÌååÏùº Ï†úÍ≥µ Ïò§Î•ò:', err);
            res.status(500).json({
                error: 'ÌéòÏù¥ÏßÄÎ•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§'
            });
        }
    });
});

// Graceful shutdown
const gracefulShutdown = async (signal) => {
    console.log(`üõë ${signal} Ïã†Ìò∏ Î∞õÏùå, ÏÑúÎ≤ÑÎ•º ÏïàÏ†ÑÌïòÍ≤å Ï¢ÖÎ£åÌï©ÎãàÎã§...`);
    
    server.close(async () => {
        console.log('üì° HTTP ÏÑúÎ≤Ñ Ï¢ÖÎ£åÎê®');
        
        try {
            await pool.end();
            console.log('üìÇ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌíÄ Ï¢ÖÎ£åÎê®');
            console.log('‚úÖ ÏïàÏ†ÑÌïú Ï¢ÖÎ£å ÏôÑÎ£å');
            process.exit(0);
        } catch (error) {
            console.error('‚ùå Ï¢ÖÎ£å Ï§ë Ïò§Î•ò:', error);
            process.exit(1);
        }
    });
    
    setTimeout(() => {
        console.error('‚è∞ Ï¢ÖÎ£å ÏãúÍ∞Ñ Ï¥àÍ≥º, Í∞ïÏ†ú Ï¢ÖÎ£åÌï©ÎãàÎã§');
        process.exit(1);
    }, 30000);
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ Promise rejection Ìï∏Îì§ÎßÅ
process.on('unhandledRejection', (reason, promise) => {
    console.error('üö® Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ Promise Rejection:', reason);
});

process.on('uncaughtException', (error) => {
    console.error('üö® Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ Exception:', error.message);
    gracefulShutdown('UNCAUGHT_EXCEPTION');
});

// ÏÑúÎ≤Ñ ÏãúÏûë
const server = app.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ ${SYSTEM_INFO.name} v${SYSTEM_INFO.version}`);
    console.log(`üì° ÏÑúÎ≤Ñ Ïã§Ìñâ Ï§ë: http://0.0.0.0:${PORT}`);
    console.log(`üåç ÌôòÍ≤Ω: ${SYSTEM_INFO.environment}`);
    console.log(`üîí Î≥¥Ïïà Í∏∞Îä•: CSP ÎπÑÌôúÏÑ±Ìôî (React Ìò∏Ìôò), Rate Limiting, JWT, bcrypt`);
    console.log('='.repeat(60));
    console.log('üìã Ï£ºÏöî ÏóîÎìúÌè¨Ïù∏Ìä∏:');
    console.log(`   ‚Ä¢ Î©îÏù∏ ÌéòÏù¥ÏßÄ: http://localhost:${PORT}`);
    console.log(`   ‚Ä¢ Ìó¨Ïä§Ï≤¥ÌÅ¨: http://localhost:${PORT}/api/health`);
    console.log(`   ‚Ä¢ DB Ï¥àÍ∏∞Ìôî: http://localhost:${PORT}/init-database?key=${config.INIT_KEY}`);
    console.log('='.repeat(60));
});

server.on('error', (error) => {
    console.error('‚ùå ÏÑúÎ≤Ñ ÏãúÏûë Ïã§Ìå®:', error);
    process.exit(1);
});

console.log(`‚è∞ ÏÑúÎ≤Ñ ÏãúÏûë ÏãúÍ∞Ñ: ${SYSTEM_INFO.startTime.toISOString()}`);
